//


: CCells ( ndx -- size ) ;
: ICells 2 * ;
: LCells 4 * ;
: WCells 4 * ;
: CArray < ( <type size> -- array )
: IArray < ( <type size> -- array )
  ICells Array ; IMMEDIATE
: LArray < ( <type size> -- array )
: WArray < ( <type size> -- array )




: c@				// 4 myarray c@
: c=				// someValue 4 myarray c=
: @
: =
: l@
: l=
: w@
: w=


: nextTokenFromInput ( charArray -- )

:

CHARACTER 4 Array myArray
someValue myArray 3 [] c=
myArray 3 cells + c@ .

CHARACTER Variable myChar
someValue myChar c=
myChar c@ .

: [] ( arrayAddr ndx -- itemAddr )


( Outer interpreter )


: c@
	primative ### ;

: c!
	primative ### ;

: execute()
	primative ### ;

: dup()
	primative ### ;

: over()
	primative ### ;

: drop()
	primative ### ;

CHARACTER 256 Array inputBuffer

: (
	[ readChar() 41 != ] whileTrue: [ ]
;

: whiletrue()
: systemRunning

: inputBuffer
: isNumber()
: ifElse()
: parseNumber()
: findWord()

: " ( inputBufferAddr -- )
	[ readChar() dup() 34 != ] whileTrue:
	[ over() c! 1 + ]
	drop()
;

: emitChar ( char -- )
	primative ### ;

: emit() ( stringAddr -- )
	[ dup c@ 0 != ]	whileTrue: [		( is current character a string terminator, 0x00? )
		dup c@ emitChar()		( emit the character )
		1 +						( move the pointer to the next character )
	]
;

: OuterInterp
	[ systemRunning c@ ] whileTrue: [
		inputBuffer readToken()
		[ inputBuffer c@ isNumber() ] if: [
			inputBuffer parseNumber()
		] else: [
			( not a mumber, so it must be a word )
			[ inputBuffer findWord() dup() ] if: [
				execute()
			] else: [
				drop()
				" ?" emit()
			]
		]
	]
;

// A code block [ code ] always pushes itself on the stack when it is executed by the
// interpreter as a thread. The "execute" word will actually execute the blocks contents

switch case [ condition ] [ action ] case [ condition ] [ action ] endswitch
[ condition ] if [ action ]
[ condition ] [ action ] if

[ condition ] if: [ action1 ] else:

// [ condition ] ifTrue: [ action1] ifFalse: [ action2 ]
[ condition ] [ action1 ] [ action2 ] if:else:()

// [ condition ] whiletrue: [ action ]
[ condition ] [ action ] whileTrue:()

// [ condition ] repeatUntilFalse: [ action ]
[ condition ] [ action ] repeatUntilFalse:()

// start to: finish do: [ action ]
start finish [ action ] to:do:()





